<!DOCTYPE html>
<html lang="zh-Hant">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>MongoDB Indexing 考試終極系統 C100DEV.20260119</title>
    <style>
        :root {
            --mongo-dark: #001e2b;
            --mongo-green: #00ed64;
            --mongo-border: #e0e0e0;
            --accent: #ffcc00;
            --bg-gray: #f0f2f5;
        }

        /* 基礎縮放設定 */
        * { box-sizing: border-box; }
        
        body { 
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif; 
            line-height: 1.6; 
            background: var(--bg-gray); 
            color: #333; 
            margin: 0; 
            padding: 0;
            font-size: 16px; /* 基礎字級 */
        }

        /* 容器等比例縮放 */
        .container { 
            width: 95%; 
            max-width: 900px; 
            margin: 0 auto; 
            padding: 10px 0 50px 0; 
        }

        /* 工具列響應式優化 */
        .toolbar { 
            position: sticky; 
            top: 10px; 
            background: white; 
            padding: 10px 20px; 
            border-radius: 30px; 
            box-shadow: 0 4px 12px rgba(0,0,0,0.1); 
            z-index: 1000; 
            margin-bottom: 20px; 
            display: flex; 
            justify-content: space-between; 
            align-items: center;
            flex-wrap: wrap; /* 小螢幕自動換行 */
            gap: 10px;
        }

        .toolbar-group {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        select, button { 
            padding: 8px 15px; 
            border-radius: 8px; 
            border: 1px solid #ddd; 
            cursor: pointer; 
            font-weight: bold;
            font-size: 0.9rem;
        }

        /* 標題與章節 */
        h2.lesson-header { 
            background: var(--mongo-dark); 
            color: var(--mongo-green); 
            padding: 15px; 
            border-radius: 12px; 
            margin-top: 30px;
            font-size: 1.25rem;
            word-break: break-all;
        }

        /* 題目卡片 */
        .question-card { 
            background: white; 
            padding: 20px; 
            border-radius: 15px; 
            margin-bottom: 20px; 
            border-left: 8px solid #ddd; 
            box-shadow: 0 2px 8px rgba(0,0,0,0.05); 
            transition: transform 0.2s;
        }
        
        .question-card:hover { transform: translateY(-2px); }
        .question-card.marked { border-left-color: var(--accent); background: #fffdf2; }
        .hidden { display: none !important; }

        .question-title { font-weight: bold; font-size: 1.1rem; margin-bottom: 15px; }

        /* 選項清單 */
        .options-list { list-style: none; padding: 0; margin: 15px 0; }
        .options-list label { 
            display: flex; 
            align-items: flex-start;
            padding: 12px; 
            border-radius: 10px; 
            transition: 0.2s; 
            border: 1px solid transparent; 
            cursor: pointer;
            margin-bottom: 5px;
        }
        .options-list label:hover { background: #f0fff4; border-color: var(--mongo-green); }
        .options-list input { margin-top: 5px; margin-right: 12px; transform: scale(1.3); flex-shrink: 0; }

        /* 按鈕視覺增強 */
        .btn-ans { background: var(--mongo-green); color: var(--mongo-dark); border: none; }
        .btn-mark { background: #f8f9fa; color: #666; }
        .marked .btn-mark { background: var(--accent); color: #000; border-color: var(--accent); }

        .answer-panel { 
            display: none; margin-top: 15px; padding: 15px; 
            background: #eefbed; border: 1px solid #c3e6cb; border-radius: 10px; 
            font-size: 0.95rem;
            animation: fadeIn 0.3s ease-in;
        }

        @keyframes fadeIn { from { opacity: 0; transform: translateY(-10px); } to { opacity: 1; transform: translateY(0); } }
        
        /* 手機版適配 */
        @media (max-width: 600px) {
            body { font-size: 14px; }
            .toolbar { border-radius: 15px; padding: 10px; }
            .toolbar-group { width: 100%; justify-content: space-between; }
            select { flex: 1; }
            .btn-ans, .btn-mark { padding: 10px; flex: 1; }
            .lesson-header { font-size: 1.1rem; }
        }
    </style>
</head>
<body>

<div class="container">
    <div class="toolbar">
        <select id="lesson-nav" onchange="jumpTo(this.value)">
            <option value="">快速跳轉章節...</option>
        </select>
        
        <div class="toolbar-group">
            <span style="font-size:14px;">已標記: <strong id="mark-count">0</strong></span>
            <button id="toggle-review" onclick="toggleReviewMode()">複習模式: 關閉</button>
        </div>
    </div>

    <div id="quiz-content"></div>
</div>

<script>
    const rawData = `
Lesson 1: Index Fundamentals & Performance (索引基礎與效能)


What is the primary purpose of an index in MongoDB?
aMongoDB 索引的主要目的為何？
A. Reduce document size
B. Improve query performance
C. Automatically sort all collections
D. Improve write performance
答案：B
解釋：索引的核心價值是加速查詢，讓 MongoDB 不必掃描整個 collection，而是透過索引快速定位文件。

Which statement best describes how MongoDB stores index data?
A. Indexes store all document fields
B. Indexes store a small, ordered portion of the data
C. Indexes duplicate entire collections
D. Indexes only exist in memory
答案：B
解釋：索引只儲存「部分欄位資料＋指向文件的 reference」，而且是有序結構，才能高效搜尋。

What happens when MongoDB executes a query without using an index?
A. Uses index cache
B. Performs a collection scan
C. Uses aggregation pipeline
D. Returns unsorted results only
答案：B
解釋：沒有索引時，MongoDB 只能做 Collection Scan，逐筆讀取所有文件，效能最差。

Which operation is more expensive when many indexes exist on a collection?
A. find
B. aggregate
C. insert
D. explain
答案：C
解釋：每次寫入（insert / update / delete）都必須同步更新所有索引，索引越多，寫入成本越高。

How many indexes are created by default for a new collection?
A. 0
B. 1
C. 2
D. Depends on schema
答案：B
解釋：MongoDB 預設只會建立一個 _id 單一欄位索引。

Which index type supports equality matches and range queries efficiently?
A. Text index
B. Hashed index
C. B-tree index
D. TTL index
答案：C
解釋：MongoDB 的索引底層結構為 B-tree，非常適合等值與範圍查詢。

Which statement about indexes is TRUE?
A. Indexes improve query performance with no trade-offs
B. Indexes reduce disk I/O
C. Indexes slow down all queries
D. Indexes are auto-created by MongoDB
答案：B
解釋：索引能減少實際需要讀取的文件數量，直接降低 disk I/O。

Which index type is created automatically when indexing an array field?
A. Compound index
B. Hashed index
C. Multikey index
D. Text index
答案：C
解釋：只要索引欄位是 array，MongoDB 會自動轉成 Multikey index，不用手動指定。

Which of the following can be a multikey index? (Select all that apply)
A. Single field index on an array
B. Compound index with one array field
C. Compound index with two array fields
D. Index on _id
答案：A、B
解釋：Multikey 允許 一個 array 欄位，但不能同時索引多個 array 欄位。1. 這是多鍵索引最基本的型態。當你在一個包含陣列的欄位上建立索引時，MongoDB 會為陣列中的每個元素建立一個索引條目。2. 複合索引可以包含一個陣列欄位。例如，索引 { a: 1, b: 1 }，如果 b 是陣列，這仍然是一個有效的多鍵索引。3. 這是 MongoDB 的一項核心限制。一個複合索引中不能包含超過一個陣列欄位。這是為了避免索引條目數量因為笛卡兒積（Cartesian product）而爆炸性增長，導致效能崩潰。4. 雖然 _id 欄位預設有索引，但 MongoDB 的規範規定 _id 欄位不能儲存陣列值。因此，_id 上的索引永遠不會是多鍵索引。













What happens if a query requires sorted output but no suitable index exists?
A. MongoDB fails the query
B. MongoDB sorts results in memory
C. MongoDB creates a temporary index
D. MongoDB ignores sort
答案：B
解釋：沒有索引支援排序時，MongoDB 需要在 memory 中排序，非常吃資源。

Which index best supports queries on { age: 30 }?
A. Compound index { name: 1, age: 1 }
B. Single field index { age: 1 }
C. Multikey index { age: 1 }
D. Text index
答案：B
解釋：單一欄位查詢，最精準就是 Single Field Index。

Why is the order of fields important in a compound index?
A. Affects storage size
B. Determines index name
C. Determines query usability and sort order
D. Determines write speed only
答案：C
解釋：複合索引遵守 前綴原則（Prefix Rule），欄位順序會直接影響可支援的查詢。

Given index { a: 1, b: 1 }, which query can use this index?
A. { b: 1 }
B. { a: 1 }
C. { b: 1, a: 1 } only
D. { c: 1 }
答案：B
解釋：可以用 {a} 或 {a, b}，但不能只查 {b}。

Which statement about “Every query should use an index” is correct?
A. It is always mandatory
B. It is a best practice guideline
C. MongoDB enforces it
D. Queries without indexes are invalid
答案：B
解釋：這是效能最佳實務建議，不是強制規則。

What is the main disadvantage of having too many indexes?
A. Increased memory usage
B. Slower write performance
C. Slower read performance
D. Larger document size
答案：B
解釋：索引越多，寫入時要更新的結構越多，寫效能會明顯下降。

 Which index type supports indexing multiple fields?
A. Single field index
B. Compound index
C. Hashed index
D. TTL index
答案：B
解釋：複合索引可同時索引多個欄位，是多條件查詢的關鍵武器！

Can MongoDB automatically detect and create indexes based on usage?
A. Yes
B. No
C. Only in Atlas
D. Only for _id
答案：B
解釋：MongoDB 不會自動建索引，但 Atlas 會「建議」你該怎麼建。

What does an index entry point to?
A. Another index
B. Document identity
C. Collection name
D. Schema definition
答案：B
解釋：索引儲存的是「欄位值 + 指向文件的 reference」。

Which of the following improves query performance the MOST?
A. Adding more RAM
B. Increasing document size
C. Creating proper indexes
D. Increasing write concern
答案：C
解釋：索引是效能優化 CP 值最高的方式，沒有之一！

Which statement about multikey indexes is TRUE?
A. Must be manually specified
B. Cannot be compound
C. Automatically created for array fields
D. Can index multiple array fields
答案：C
解釋：只要欄位是 array，MongoDB 會自動變成 multikey index，但只能有一個 array 欄位。

Lesson 2: Creating a Single Field Index in MongoDB


Which method is used to create a single field index in MongoDB?
MongoDB 中用來建立單一欄位索引的方法是？
A. create()
B. createIndex()
C. addIndex()
D. ensureIndex()
答案：B
解釋：MongoDB 使用 createIndex() 來建立索引，需在方法中指定欄位與排序方向。

What does a single field index support?
單一欄位索引支援哪些功能？
A. Queries and sorts on one field
B. Queries on multiple fields
C. Automatic sharding
D. Aggregation pipelines only
答案：A
解釋：單一欄位索引可有效支援「單一欄位」的查詢與排序。

Which of the following is a correct syntax to create a single field index?
以下哪一個是正確的單一欄位索引建立語法？
A. db.coll.createIndex(fieldname)
B. db.coll.createIndex({ fieldname: 1 })
C. db.coll.createIndex([fieldname])
D. db.coll.index({ fieldname: "asc" })
答案：B
解釋：createIndex() 需要傳入一個物件，指定欄位名稱與排序方向（1 或 -1）。

What does the value 1 indicate when creating an index?
建立索引時，數值 1 代表什麼？
A. Text index
B. Hashed index
C. Ascending order
D. Descending order
答案：C
解釋：1 代表遞增排序（Ascending），-1 則代表遞減排序（Descending）。

Which option enforces uniqueness when creating a single field index?
建立單一欄位索引時，哪個選項可以強制唯一性？
A. { required: true }
B. { unique: true }
C. { distinct: true }
D. { primary: true }
答案：B
解釋：{ unique: true } 會確保索引欄位中的值不可重複。

What happens if duplicate values already exist when creating a unique index?
若欄位中已存在重複值，建立 unique index 會發生什麼事？
A. MongoDB removes duplicates automatically
B. MongoDB creates the index anyway
C. Index creation fails
D. Old documents are replaced
答案：C
解釋：若資料中已有重複值，MongoDB 不會建立 unique index，並回傳錯誤。

Which command lists all indexes in a collection?
哪一個指令可查看集合中所有索引？
A. db.coll.indexes()
B. db.coll.showIndexes()
C. db.coll.getIndexes()
D. db.coll.explainIndexes()
答案：C
解釋：getIndexes() 會列出集合內所有已建立的索引。

Which method helps determine whether a query is using an index?
哪個方法可用來判斷查詢是否使用索引？
A. stats()
B. getIndexes()
C. explain()
D. profile()
答案：C
解釋：explain() 會顯示查詢的執行計畫（Execution Plan）。

What does the IXSCAN stage indicate in an explain plan?
在 explain 結果中，IXSCAN 代表什麼？
A. Collection scan
B. Index scan
C. In-memory sort
D. Document fetch only
答案：B
解釋：IXSCAN 表示 MongoDB 正在使用索引掃描，是理想的查詢狀態。

What does the COLLSCAN stage indicate?
COLLSCAN 階段代表什麼？
A. Using multiple indexes
B. Index merge
C. Full collection scan
D. Cached result
答案：C
解釋：COLLSCAN 表示進行全表掃描，代表沒有使用索引，效能較差。

What does the FETCH stage represent in an execution plan?
FETCH 階段代表什麼？
A. Sorting documents
B. Reading documents from disk
C. Reading actual documents after index scan
D. Writing documents
答案：C
解釋：FETCH 通常搭配 IXSCAN，代表依索引找到位置後，再讀取實際文件內容。

What does the SORT stage indicate in explain output?
explain 中出現 SORT 代表什麼？
A. Sorting using index
B. Sorting in memory
C. Sorting during insert
D. Sorting during index creation
答案：B
解釋：SORT 代表在記憶體中進行排序，通常表示沒有索引支援該排序條件。

What type of index is created when a single field index is built on an array field?
當單一欄位索引建立在陣列欄位上時，會變成哪種索引？
A. Compound index
B. Hashed index
C. Multikey index
D. TTL index
答案：C
解釋：只要索引欄位是陣列，MongoDB 會自動建立 Multikey index。

What happens if you insert a document with a duplicate value into a unique indexed field?
若在 unique index 欄位插入重複值，會發生什麼事？
A. Document is inserted and old one removed
B. Document is inserted and both remain
C. Duplicate key error, document inserted
D. Duplicate key error, document not inserted
答案：D
解釋：unique index 會阻止重複值寫入，MongoDB 會回傳 duplicate key error，且不會插入文件。

Which statement best describes a single field index?
以下哪個最正確描述單一欄位索引？
A. Supports efficient querying against one field
B. Supports efficient querying against multiple fields
C. Only works on scalar values
D. Automatically created for all fields
答案：A
解釋：單一欄位索引專門優化「單一欄位」的查詢，可用於純量或陣列欄位。

Lesson 3: Creating a Multikey Index in MongoDB

What is a multikey index?
什麼是 Multikey Index（多鍵索引）？
A. An index on one field only where the field is not an array
B. An index where one of the indexed fields contains an array
C. An index on more than one field where none of the fields are arrays
D. An index on more than one field where multiple fields are arrays
答案：B
解釋：只要索引的欄位中「有任一個欄位是陣列」，該索引就是 Multikey Index，適用於單一欄位或複合索引，但複合索引中只能有一個陣列欄位。

What happens when you create an index on an array field?
當你在陣列欄位上建立索引時，MongoDB 會發生什麼事？
A. Only the first element in the array is indexed
B. MongoDB creates one index entry for the entire array
C. MongoDB creates an index key for each element in the array
D. MongoDB ignores array fields
答案：C
解釋：MongoDB 會為陣列中的每一個元素建立索引鍵，讓查詢可以直接比對元素而非掃描整個陣列。

Which of the following statements about multikey indexes is correct?
以下哪一個關於 Multikey Index 的敘述是正確的？
A. Multikey indexes must be manually specified
B. Multikey indexes only work with numeric arrays
C. Multikey indexes are automatically created when indexing an array field
D. Multikey indexes cannot be used for queries
答案：C
解釋：只要索引欄位是陣列，MongoDB 會自動建立 Multikey Index，不需要額外指定。

In a compound index, how many array fields are allowed?
在複合索引中，最多可以有幾個陣列欄位？
A. 1
B. 2
C. 5
D. Unlimited
答案：A
解釋：MongoDB 限制一個複合索引中「最多只能有一個陣列欄位」，否則無法建立索引。

Which command creates a single field multikey index on the accounts array?
以下哪個指令可在 accounts 陣列欄位上建立單一欄位的 Multikey Index？
A. db.customers.createIndex(accounts)
B. db.customers.createIndex({ accounts: 1 })
C. db.customers.createIndex([accounts])
D. db.customers.ensureIndex({ accounts: 1 })
答案：B
解釋：使用 createIndex() 並指定陣列欄位與排序方向即可，MongoDB 會自動判斷為 Multikey Index。

Which method is used to view all indexes in a collection?
哪一個方法可用來查看集合中所有索引？
A. db.customers.indexes()
B. db.customers.showIndexes()
C. db.customers.getIndexes()
D. db.customers.explainIndexes()
答案：C
解釋：getIndexes() 會列出集合中目前存在的所有索引，包括 Multikey Index。

What does the IXSCAN stage indicate in an explain plan for a multikey query?
在使用 Multikey Index 的查詢 explain 計畫中，IXSCAN 代表什麼？
A. Sorting documents in memory
B. Full collection scan
C. Reading documents only
D. Query is using an index
答案：D
解釋：IXSCAN 表示查詢正在使用索引（包含 Multikey Index），是效能良好的查詢狀態。

What does the COLLSCAN stage indicate when querying an array field?
在查詢陣列欄位時，出現 COLLSCAN 代表什麼？
A. MongoDB is using a multikey index
B. MongoDB is scanning the entire collection
C. MongoDB is sorting using index order
D. MongoDB is reading cached results
答案：B
解釋：COLLSCAN 表示未使用索引而進行全表掃描，通常代表缺少合適的 Multikey Index。

Lesson 4: Working with Compound Indexes in MongoDB

What is a compound index?
什麼是 Compound Index（複合索引）？
A. An index that supports queries that combine the field name and the value into one string
B. An index that supports queries against unknown or arbitrary fields
C. An index that contains references to multiple fields within a document
D. An index that supports queries that are run on two collections at the same time
答案：C
解釋：複合索引是在同一個索引結構中同時包含多個欄位及其排序方式，用來加速多欄位查詢。

What is the main characteristic of a compound index?
複合索引的主要特性是什麼？
A. Index on a single field only
B. Index on multiple fields
C. Index only supports array fields
D. Index only supports sorting
答案：B
解釋：複合索引是建立在多個欄位之上的索引結構，可同時支援多條件查詢與排序。

Which of the following statements about compound indexes is correct?
以下哪一個關於複合索引的敘述是正確的？
A. Compound indexes can include unlimited array fields
B. Compound indexes cannot be used for sorting
C. Compound indexes can become multikey indexes if they include an array field
D. Compound indexes are created automatically by MongoDB
答案：C
解釋：只要複合索引中包含陣列欄位，就會自動成為 Multikey Index，但整個索引只能有一個陣列欄位。

What is the maximum number of array fields allowed in a compound index?
一個複合索引最多可以包含幾個陣列欄位？
A. 0
B. 1
C. 2
D. Unlimited
答案：B
解釋：MongoDB 規定一個索引中最多只能有一個欄位是陣列，否則無法建立索引。

Why does the order of fields matter in a compound index?
為什麼複合索引中欄位順序很重要？
A. It affects document size
B. It affects index name
C. It affects query optimization and index usability
D. It affects write concern
答案：C
解釋：複合索引遵循前綴原則，欄位順序會直接影響哪些查詢能有效使用該索引以及排序是否能被索引支援。

What is the recommended order of fields in a compound index?
複合索引中建議的欄位順序是什麼？
A. Sort, Range, Equality
B. Range, Sort, Equality
C. Equality, Sort, Range
D. The order does not matter
答案：C
解釋：建議順序為 Equality（相等條件）→ Sort（排序）→ Range（範圍），可讓查詢最佳化並減少處理成本。

Which type of query condition should be placed first in a compound index?
在複合索引中，哪種類型的查詢條件應該放在第一個欄位？
A. Range query
B. Sort field
C. Equality match
D. Projection field
答案：C
解釋：相等條件能快速縮小搜尋範圍，應放在索引最前面以減少需要掃描的索引鍵數量。

What benefit does index-based sorting provide?
使用索引排序的好處是什麼？
A. Improves write performance
B. Eliminates in-memory sorting
C. Reduces index size
D. Allows unlimited array fields
答案：B
解釋：若排序順序與索引一致，MongoDB 可直接依索引順序回傳結果，避免在記憶體中進行 SORT。

What does it mean when a query is covered by an index?
什麼情況下稱為「索引覆蓋查詢（Covered Query）」？
A. The query uses multiple indexes
B. The query requires fetching documents from memory
C. All required fields are returned directly from the index
D. The query includes a sort stage
答案：C
解釋：當查詢所需的欄位全部包含在索引中，MongoDB 不需 FETCH 文件即可回傳結果，即為覆蓋查詢。

Which execution stage indicates a covered query in explain output?
在 explain 結果中，哪個階段代表索引覆蓋查詢？
A. FETCH
B. SORT
C. COLLSCAN
D. PROJECTION_COVERED
答案：D
解釋：PROJECTION_COVERED 表示所有需要的資料皆由索引提供，無需從集合中讀取文件。

What does the IXSCAN stage indicate in a compound index query?
在使用複合索引的查詢中，IXSCAN 代表什麼？
A. In-memory sorting
B. Full collection scan
C. Index scan is being used
D. Projection only
答案：C
解釋：IXSCAN 表示 MongoDB 正在使用索引（包含複合索引）進行查詢，是效能良好的執行計畫。

Lesson 5: Deleting MongoDB Indexes

What is the impact of deleting an index that supports a query?
刪除正在支援查詢的索引會造成什麼影響？
A. Query performance improves
B. Query performance is negatively affected
C. Query will fail
D. Query behavior is unchanged
答案：B
解釋：刪除支援查詢的索引會導致 MongoDB 可能改用 COLLSCAN 全表掃描，查詢效能因此下降。

Which command deletes a single index from a MongoDB collection?
哪一個指令可用來刪除單一索引？
A. deleteIndex()
B. dropIndexes()
C. dropIndex()
D. removeIndex()
答案：C
解釋：dropIndex() 用於刪除集合中的單一索引，可使用索引名稱或索引鍵指定。

Which index in a MongoDB collection cannot be deleted?
MongoDB 集合中哪一個索引無法被刪除？
A. Compound index
B. Multikey index
C. Text index
D. _id index
答案：D
解釋：每個集合都預設存在 _id 索引，該索引由 MongoDB 內部使用，不可刪除。

Which command removes all indexes except the default _id index?
哪一個指令會刪除集合中除了 _id 以外的所有索引？
A. dropIndex()
B. dropIndexes()
C. getIndexes()
D. hideIndex()
答案：B
解釋：dropIndexes() 會刪除集合中所有使用者建立的索引，但保留預設的 _id 索引。

Before deleting an index, which command should be used to evaluate its impact on query performance?
在刪除索引前，應使用哪個指令評估對查詢效能的影響？
A. dropIndex()
B. dropIndexes()
C. getIndexes()
D. hideIndex()
答案：D
解釋：hideIndex() 會讓 MongoDB 查詢時不使用該索引但仍維護索引資料，可安全評估移除索引對效能的影響。

Which statement about hideIndex() is correct?
以下哪一項對 hideIndex() 的描述是正確的？
A. Hidden indexes are deleted permanently
B. Hidden indexes are not updated
C. Hidden indexes are ignored by the query planner
D. Hidden indexes cause queries to fail
答案：C
解釋：被隱藏的索引不會被查詢規劃器使用，但 MongoDB 仍會持續更新索引鍵，方便日後快速還原使用。



Lesson 6: 整合模擬考


Which statement best describes a MongoDB index?
下列哪一項最能正確描述 MongoDB 索引？
A. Stores a full copy of the collection
B. Improves query performance by scanning all documents
C. Improves query performance by reducing scanned documents
D. Is required for every query
答案：C
解釋：索引透過減少需掃描的文件數量來提升查詢效能，是 MongoDB 查詢最佳化的核心機制。

What happens if you insert a document with a duplicate value into a unique indexed field?
若在 unique index 欄位插入重複值，會發生什麼事？
A. Document is inserted and old one removed
B. Document is inserted and both remain
C. Duplicate key error, document inserted
D. Duplicate key error, document not inserted
答案：D
解釋：unique index 會阻止重複值寫入，MongoDB 會回傳 duplicate key error，且文件不會被插入。

Which index type is automatically created for every MongoDB collection?
MongoDB 每個集合預設會自動建立哪一種索引？
A. Single field index
B. Compound index
C. Multikey index
D. _id index
答案：D
解釋：每個集合都自動建立 _id 索引，用於唯一識別文件且不可刪除。

What is a multikey index in MongoDB?
MongoDB 中什麼是 Multikey Index？
A. An index on multiple collections
B. An index where one indexed field contains an array
C. An index on multiple fields with multiple arrays
D. An index used only for sorting
答案：B
解釋：只要索引欄位中包含陣列，該索引即為 multikey index，可用於單一欄位或複合索引。

In a compound index, how many fields can be arrays?
在複合索引中，最多可以有幾個欄位是陣列？
A. 0
B. 1
C. 2
D. Unlimited
答案：B
解釋：MongoDB 規定複合索引中只能有一個欄位是陣列，否則無法建立索引。

Which execution stage indicates that MongoDB is using an index?
哪一個 explain() 執行階段代表 MongoDB 正在使用索引？
A. COLLSCAN
B. FETCH
C. SORT
D. IXSCAN
答案：D
解釋：IXSCAN 代表 MongoDB 透過索引掃描資料，而非進行全表掃描。

Which command deletes a single index from a collection?
哪一個指令用來刪除單一索引？
A. deleteIndex()
B. dropIndexes()
C. dropIndex()
D. removeIndex()
答案：C
解釋：dropIndex() 可透過索引名稱或索引鍵刪除指定索引。

Which command removes all indexes except the default _id index?
哪一個指令會刪除集合中除了 _id 以外的所有索引？
A. dropIndex()
B. dropIndexes()
C. getIndexes()
D. hideIndex()
答案：B
解釋：dropIndexes() 會刪除所有使用者建立的索引，但 _id 索引會被保留。

What is the impact of deleting an index that supports a query?
刪除正在支援查詢的索引會造成什麼影響？
A. Query performance improves
B. Query performance is negatively affected
C. Query will fail
D. Query behavior is unchanged
答案：B
解釋：移除索引後查詢可能退化為 COLLSCAN，導致效能下降但不會失敗。

Before deleting an index, which command should be used to evaluate its impact on query performance?
在刪除索引前，應使用哪個指令評估對查詢效能的影響？
A. dropIndex()
B. dropIndexes()
C. getIndexes()
D. hideIndex()
答案：D
解釋：hideIndex() 會讓查詢不使用該索引但仍維護索引資料，能安全評估效能影響並快速還原。

Lesson 7: Introduction to MongoDB Aggregation

Which task CANNOT be performed within an aggregation pipeline? 
A. Filtering documents based on a criteria 
B. Grouping documents together to calculate summaries 
C. Permanently altering the original documents in the database 
D. Calculating the total sum of a field across multiple documents 
答案：C 
解釋：Aggregation 只是對資料進行分析、彙總並回傳結果，過程是不會（does not permanently alter）改變資料庫中的原始文件的。

Which method is used to perform an aggregation operation in MongoDB? 
A. db.collection.aggregation() 
B. db.collection.aggregate() 
C. db.collection.group() 
D. db.collection.filter() 
答案：B 
解釋：正確的指令名稱是 aggregate()，它接受一個陣列作為參數來定義聚合管線（Aggregation Pipeline）。

What is the correct definition of a "Stage" in an aggregation pipeline? 
A. A separate database where data is stored 
B. A series of operations completed at the same time 
C. A single operation performed on the data in the pipeline 
D. A method used to import data from outside sources 
答案：C 
解釋：Stage（階段）是管線中的單一操作步驟，資料會依序經過這些階段處理，但不會永久改變原始資料。

In an aggregation pipeline, how are the stages organized and executed? 
A. Stages are executed in random order 
B. Stages are executed simultaneously (in parallel) 
C. Stages are completed one at a time, in a specified order 
D. Only one stage can be used per aggregation command 
答案：C 
解釋：Aggregation Pipeline 是一系列按順序（in order）逐一完成的階段，前一個階段的輸出會成為下一個階段的輸入。

Which stage is used to filter documents to match a specific criteria, similar to the find() method? 
A. $sort 
B. $match 
C. $group 
D. $project 
答案：B 
解釋：$match 的功能就是篩選，讓符合條件的文件進入管線的下一個階段。

When using the $group stage, which field MUST be specified to define the grouping criteria? 
A. $id 
B. _id 
C. groupKey 
D. customerId 
答案：B 
解釋：在 $group 階段中，必須使用 _id 欄位來指定分組的基準（Key）。

Which stage would you use if you wanted to output documents in a specific descending or ascending order? 
A. $limit 
B. $match 
C. $sort 
D. $unwind 
答案：C 
解釋：$sort 階段用於將文件排序，例如 { total: -1 } 表示依照 total 欄位進行降冪排序。

What does the $unwind stage do in an aggregation pipeline? 
A. Combines multiple documents into one 
B. Deconstructs an array field into multiple documents 
C. Joins two different collections together 
D. Removes specific fields from a document 
答案：B 
解釋：$unwind 會將陣列欄位展開，陣列中的每個元素都會對應生成一筆新的文件，常用於處理巢狀陣列資料。

Which of the following describes the structure of an aggregation command? 
A. db.collection.aggregate({ $stage1 }, { $stage2 }) 
B. db.collection.aggregate([ { $stage1 }, { $stage2 } ]) 
C. db.collection.aggregate( { pipeline: [ stage1, stage2 ] } ) 
D. db.collection.aggregate("stage1", "stage2") 
答案：B 
解釋：aggregate() 方法接收一個包含各個階段物件的「陣列 (Array)」，因此必須使用方括號 [] 包裹。

What is the primary purpose of the $lookup stage? 
A. To filter documents based on a search string 
B. To perform a join with another collection 
C. To limit the number of documents returned 
D. To rename fields in the output documents 
答案：B 
解釋：$lookup 類似 SQL 的 JOIN，可以用來關聯同一個資料庫中另一個集合（collection）的資料。


Which of the following tasks cannot be completed with an aggregation pipeline[官方]?
A. Filtering for relevant pieces of data Correct!
B. Finding data from outside sources
C. Grouping documents
D. Calculating total values from a field across many documents
答案：B 
解釋：B. You cannot use aggregation to find data from outside sources.  

Select an answer choice and then click "See Results" to submit. Which command performs an aggregation operation by using an aggregation pipeline? (Select one.)[官方]
A. group()
B. filter()
C. aggregation()
D. aggregate()
答案：D 
解釋：D aggregate() performs an aggregation operation by using an aggregation pipeline. aggregate() takes an array of aggregation stages to form the pipeline. An aggregation function is written as db.collection.aggregate().


Lesson 8: Using $match and $group Stages in a MongoDB Aggregation Pipeline

What is the main benefit of placing a $match stage as early as possible in an aggregation pipeline? 
A. It allows the pipeline to use indexes and reduces the number of documents to process 
B. It automatically sorts the documents in ascending order 
C. It permanently changes the field names in the original collection 
D. It allows the $group stage to be skipped entirely 
答案：A 
解釋：將 $match 放在管線越前面的位置，可以利用索引來過濾資料，減少後續階段需要處理的文件數量，進而提升效能。

In the $group stage, what does the _id field represent? 
A. The unique identifier of the original document 
B. The group key used to aggregate documents by distinct values 
C. The name of the collection being queried 
D. A random number generated by the database 
答案：B 
解釋：在 $group 階段中，_id 用於定義分組鍵（group key），MongoDB 會根據這個鍵的每個唯一值輸出一個彙總文件。

Which of the following is the correct syntax for a $match stage filtering for a specific state? 
A. { $match: { "state" = "CA" } } 
B. { $filter: { "state": "CA" } } 
C. { $match: { "state": "CA" } } 
D. { $match: [ "state", "CA" ] } 
答案：C 
解釋：$match 的語法與 find() 相同，使用大括號物件格式 { "field_name": "value" }。

In the $group stage, what is an "accumulator" used for? 
A. To filter out documents that don't match the group key 
B. To perform calculations like $count or $sum on grouped documents 
C. To rename the collection in the database 
D. To prevent the pipeline from using too much memory 
答案：B 
解釋：累加器（accumulator）運算子（如 $count、$sum、$avg）用於在分組後對資料進行計算。

Review the following code. What will be the output of this pipeline? db.zips.aggregate([ { $match: { state: "CA" } }, { $group: { _id: "$city", totalZips: { $count : { } } } } ]) 
A. A list of all zip codes in the city of California 
B. A single document containing the total number of cities in the US 
C. One document for each unique city in California, showing the count of zip codes for that city 
D. A list of all states that have a city named CA 
答案：C 
解釋：此管線先篩選出 state 為 "CA" 的文件，然後按 city 分組，並計算每個城市所擁有的郵遞區號總數。

Which of the following describes the output of a $group stage? 
A. It returns the same number of documents that entered the stage 
B. It returns one document for each unique value of the group key 
C. It returns a single array containing all documents 
D. It returns only the fields that were used in the $match stage 
答案：B 
解釋：$group 階段會壓縮資料，針對分組鍵（group key）的每一個不重複值（distinct value），最終只輸出一個對應的文件。

What is the correct way to reference a field name as a group key inside the $group stage (e.g., the city field)? 
A. "city" 
B. "$city" 
C. { city } 
D. field(city) 
答案：B 
解釋：在聚合階段中，引用文件中的欄位值作為表達式時，必須在欄位名稱前加上錢字號 $ 並用引號括起來，例如 "$city"。



`;

    let markedIds = new Set();
    let isReviewMode = false;

    function init() {
        const container = document.getElementById('quiz-content');
        const nav = document.getElementById('lesson-nav');
        const sections = rawData.trim().split(/\n(?=Lesson \d:)/); 
        
        let qGlobalId = 1;

        sections.forEach((sec) => {
            const lines = sec.trim().split('\n');
            const lessonTitle = lines.shift();
            const lessonMatch = lessonTitle.match(/\d+/);
            const lessonId = "lesson-" + (lessonMatch ? lessonMatch[0] : qGlobalId);

            const h2 = document.createElement('h2');
            h2.className = 'lesson-header';
            h2.id = lessonId;
            h2.textContent = lessonTitle;
            container.appendChild(h2);

            const opt = document.createElement('option');
            opt.value = lessonId;
            opt.textContent = lessonTitle;
            nav.appendChild(opt);

            const questions = lines.join('\n').trim().split(/\n\n+/);
            questions.forEach(qBlock => {
                if(qBlock.trim()) renderQuestion(qBlock, qGlobalId++, container);
            });
        });
    }

    function renderQuestion(block, id, container) {
        const lines = block.trim().split('\n');
        let title = "", options = [], answer = "", exp = "";

        lines.forEach(l => {
            if (l.startsWith('答案：')) answer = l.replace('答案：', '').trim();
            else if (l.startsWith('解釋：')) exp = l.replace('解釋：', '').trim();
            else if (l.match(/^[A-Z]\.\s/)) options.push(l);
            else if (l.trim() !== "") title += l + " ";
        });

        const isMulti = answer.length > 1 && (answer.includes(',') || answer.includes('，') || /[A-Z]{2,}/.test(answer));
        const card = document.createElement('div');
        card.className = 'question-card';
        card.id = `q-card-${id}`;
        card.innerHTML = `
            <div class="question-title">
                <strong>#${id}</strong> ${title} ${isMulti ? '<span style="color:#d9534f; font-size:0.8em;">(複選)</span>' : ''}
            </div>
            <div class="options-list">
                ${options.map(o => `<label><input type="${isMulti ? 'checkbox' : 'radio'}" name="q${id}"><span>${o}</span></label>`).join('')}
            </div>
            <div style="display:flex; gap:10px;">
                <button class="btn-ans" onclick="toggleAns(${id})">顯示解析</button>
                <button class="btn-mark" onclick="toggleMark(${id})">標記題目</button>
            </div>
            <div class="answer-panel" id="ans-${id}">
                <b style="color:#28a745;">答案：${answer}</b>
                <div style="margin-top:10px; border-top:1px dashed #ccc; padding-top:10px;">${exp}</div>
            </div>
        `;
        container.appendChild(card);
    }

    function toggleAns(id) {
        const panel = document.getElementById(`ans-${id}`);
        panel.style.display = (panel.style.display === 'block') ? 'none' : 'block';
    }

    function toggleMark(id) {
        const card = document.getElementById(`q-card-${id}`);
        if (markedIds.has(id)) {
            markedIds.delete(id);
            card.classList.remove('marked');
        } else {
            markedIds.add(id);
            card.classList.add('marked');
        }
        document.getElementById('mark-count').textContent = markedIds.size;
        if (isReviewMode) applyFilter();
    }

    function toggleReviewMode() {
        isReviewMode = !isReviewMode;
        const btn = document.getElementById('toggle-review');
        btn.textContent = isReviewMode ? "複習模式: 開啟" : "複習模式: 關閉";
        btn.style.background = isReviewMode ? "var(--accent)" : "#fff";
        applyFilter();
    }

    function applyFilter() {
        const cards = document.querySelectorAll('.question-card');
        cards.forEach(card => {
            const id = parseInt(card.id.replace('q-card-', ''));
            card.classList.toggle('hidden', isReviewMode && !markedIds.has(id));
        });
        document.querySelectorAll('.lesson-header').forEach(h => {
            let next = h.nextElementSibling;
            let hasVisible = false;
            while(next && next.classList.contains('question-card')) {
                if(!next.classList.contains('hidden')) { hasVisible = true; break; }
                next = next.nextElementSibling;
            }
            h.classList.toggle('hidden', isReviewMode && !hasVisible);
        });
    }

    function jumpTo(id) { 
        if(id) {
            const el = document.getElementById(id);
            const offset = 80; // 考慮到 sticky toolbar 的高度
            const bodyRect = document.body.getBoundingClientRect().top;
            const elementRect = el.getBoundingClientRect().top;
            const elementPosition = elementRect - bodyRect;
            const offsetPosition = elementPosition - offset;

            window.scrollTo({ top: offsetPosition, behavior: 'smooth' });
        } 
    }

    init();
</script>
</body>
</html>
